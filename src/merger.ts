import * as fs from 'fs';
import * as path from 'path';

/**
 * Faz merge seguro de conteúdo de .gitignore existente com novo conteúdo
 */
export class Merger {
  /**
   * Faz merge do .gitignore existente com o novo conteúdo
   */
  public merge(
    existingContent: string,
    newContent: string,
    detectedStacks: string[]
  ): string {
    // Extrai comentários do usuário (linhas que começam com # e não são do header padrão)
    const userComments = this.extractUserComments(existingContent);
    
    // Remove duplicatas do novo conteúdo
    const cleanedNewLines = this.removeDuplicates(newContent);
    
    // Remove duplicatas do conteúdo existente
    const cleanedExistingLines = this.removeDuplicates(existingContent);
    
    // Combina tudo
    const header = this.generateHeader(detectedStacks);
    const merged = this.combineContent(
      header, 
      userComments, 
      cleanedNewLines, 
      cleanedExistingLines
    );
    
    return merged;
  }

  /**
   * Gera o header do arquivo
   */
  public generateHeader(stacks: string[]): string {
    const stacksList = stacks.join(',');
    return `# Generated by smart-gitignore
# Stacks: ${stacksList}

`;
  }

  /**
   * Extrai comentários do usuário (comentários que não são do header padrão ou templates gerados)
   */
  private extractUserComments(content: string): string[] {
    const lines = content.split('\n');
    const userComments: string[] = [];
    let headerFound = false;
    let inGeneratedSection = false;

    for (const line of lines) {
      // Detecta se é o header do smart-gitignore
      if (line.includes('Generated by smart-gitignore')) {
        headerFound = true;
        continue;
      }
      
      if (headerFound && line.startsWith('# Stacks:')) {
        continue;
      }
      
      if (headerFound && line.trim() === '') {
        continue;
      }
      
      // Detecta início de seção gerada
      if (line.includes('# User comments:') || line.includes('# Generated rules:') || 
          line.includes('# Additional existing rules:')) {
        inGeneratedSection = true;
        continue;
      }
      
      // Se está em seção gerada, ignora comentários (são dos templates)
      if (inGeneratedSection) {
        // Se encontrar uma linha não-comentário, pode ser conteúdo do usuário
        const trimmed = line.trim();
        if (trimmed && !trimmed.startsWith('#')) {
          // Não é comentário, então não é parte dos templates gerados
          // Mas também não é comentário do usuário
        }
        continue;
      }
      
      // Comentários do usuário (apenas antes das seções geradas)
      if (headerFound && !inGeneratedSection && line.trim().startsWith('#') && 
          !line.includes('Generated by') && 
          !line.includes('Stacks:') &&
          !line.includes('User comments:') &&
          !line.includes('Generated rules:') &&
          !line.includes('Additional existing rules:')) {
        userComments.push(line);
      }
    }

    // Remove duplicatas de comentários
    return Array.from(new Set(userComments));
  }

  /**
   * Remove linhas duplicadas do conteúdo
   */
  private removeDuplicates(content: string): string[] {
    const lines = content.split('\n');
    const seen = new Set<string>();
    const unique: string[] = [];

    for (const line of lines) {
      const trimmed = line.trim();
      
      // Ignora linhas vazias e comentários para comparação de duplicatas
      if (trimmed === '' || trimmed.startsWith('#')) {
        unique.push(line);
        continue;
      }

      // Normaliza a linha para comparação (remove espaços extras)
      const normalized = trimmed.toLowerCase();
      
      if (!seen.has(normalized)) {
        seen.add(normalized);
        unique.push(line);
      }
    }

    return unique;
  }

  /**
   * Combina todo o conteúdo de forma organizada
   */
  private combineContent(
    header: string,
    userComments: string[],
    newLines: string[],
    existingLines: string[]
  ): string {
    const parts: string[] = [header.trim()];

    // Adiciona comentários do usuário se existirem (e não forem apenas comentários vazios)
    const realUserComments = userComments.filter(c => {
      const trimmed = c.trim();
      return trimmed && 
             trimmed !== '# User comments:' && 
             trimmed !== '# Generated rules:' &&
             trimmed !== '# Additional existing rules:';
    });
    
    if (realUserComments.length > 0) {
      parts.push('# User comments:');
      parts.push(...realUserComments);
      parts.push('');
    }

    // Adiciona novo conteúdo gerado
    parts.push('# Generated rules:');
    parts.push(...newLines);

    // Adiciona conteúdo existente que não está no novo conteúdo
    const newLinesSet = new Set(newLines.map(l => l.trim().toLowerCase()));
    
    const additionalLines: string[] = [];
    for (const line of existingLines) {
      const trimmed = line.trim();
      // Ignora linhas vazias, comentários padrão e duplicatas
      if (trimmed && 
          !trimmed.startsWith('#') && 
          !newLinesSet.has(trimmed.toLowerCase()) &&
          !trimmed.includes('Generated by smart-gitignore') &&
          !trimmed.includes('Stacks:')) {
        additionalLines.push(line);
      }
    }

    if (additionalLines.length > 0) {
      parts.push('');
      parts.push('# Additional existing rules:');
      parts.push(...additionalLines);
    }

    return parts.join('\n').replace(/\n{3,}/g, '\n\n') + '\n';
  }

  /**
   * Lê o conteúdo do .gitignore existente
   */
  public readExisting(gitignorePath: string): string {
    if (!fs.existsSync(gitignorePath)) {
      return '';
    }
    
    try {
      return fs.readFileSync(gitignorePath, 'utf-8');
    } catch (error) {
      throw new Error(`Erro ao ler .gitignore existente: ${error}`);
    }
  }

  /**
   * Escreve o conteúdo final no .gitignore
   */
  public write(gitignorePath: string, content: string): void {
    try {
      fs.writeFileSync(gitignorePath, content, 'utf-8');
    } catch (error) {
      throw new Error(`Erro ao escrever .gitignore: ${error}`);
    }
  }
}

