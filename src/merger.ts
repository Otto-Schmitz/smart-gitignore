import * as fs from 'fs';
import * as path from 'path';

/**
 * Safely merges existing .gitignore content with new content
 */
export class Merger {
  /**
   * Merges existing .gitignore with new content
   */
  public merge(
    existingContent: string,
    newContent: string,
    detectedStacks: string[]
  ): string {
    // Extract user comments (lines starting with # that are not from standard header)
    const userComments = this.extractUserComments(existingContent);
    
    // Remove duplicates from new content
    const cleanedNewLines = this.removeDuplicates(newContent);
    
    // Remove duplicates from existing content
    const cleanedExistingLines = this.removeDuplicates(existingContent);
    
    // Combine everything
    const header = this.generateHeader(detectedStacks);
    const merged = this.combineContent(
      header, 
      userComments, 
      cleanedNewLines, 
      cleanedExistingLines
    );
    
    return merged;
  }

  /**
   * Generates the file header
   */
  public generateHeader(stacks: string[]): string {
    const stacksList = stacks.join(',');
    return `# Generated by smart-gitignore
# Stacks: ${stacksList}

`;
  }

  /**
   * Extracts user comments (comments that are not from standard header or generated templates)
   */
  private extractUserComments(content: string): string[] {
    const lines = content.split('\n');
    const userComments: string[] = [];
    let headerFound = false;
    let inGeneratedSection = false;

    for (const line of lines) {
      // Detect if it's the smart-gitignore header
      if (line.includes('Generated by smart-gitignore')) {
        headerFound = true;
        continue;
      }
      
      if (headerFound && line.startsWith('# Stacks:')) {
        continue;
      }
      
      if (headerFound && line.trim() === '') {
        continue;
      }
      
      // Detect start of generated section
      if (line.includes('# User comments:') || line.includes('# Generated rules:') || 
          line.includes('# Additional existing rules:')) {
        inGeneratedSection = true;
        continue;
      }
      
      // If in generated section, ignore comments (they're from templates)
      if (inGeneratedSection) {
        // If finding a non-comment line, it could be user content
        const trimmed = line.trim();
        if (trimmed && !trimmed.startsWith('#')) {
          // Not a comment, so not part of generated templates
          // But also not a user comment
        }
        continue;
      }
      
      // User comments (only before generated sections)
      if (headerFound && !inGeneratedSection && line.trim().startsWith('#') && 
          !line.includes('Generated by') && 
          !line.includes('Stacks:') &&
          !line.includes('User comments:') &&
          !line.includes('Generated rules:') &&
          !line.includes('Additional existing rules:')) {
        userComments.push(line);
      }
    }

    // Remove duplicate comments
    return Array.from(new Set(userComments));
  }

  /**
   * Removes duplicate lines from content
   */
  private removeDuplicates(content: string): string[] {
    const lines = content.split('\n');
    const seen = new Set<string>();
    const unique: string[] = [];

    for (const line of lines) {
      const trimmed = line.trim();
      
      // Ignore empty lines and comments for duplicate comparison
      if (trimmed === '' || trimmed.startsWith('#')) {
        unique.push(line);
        continue;
      }

      // Normalize line for comparison (remove extra spaces)
      const normalized = trimmed.toLowerCase();
      
      if (!seen.has(normalized)) {
        seen.add(normalized);
        unique.push(line);
      }
    }

    return unique;
  }

  /**
   * Combines all content in an organized way
   */
  private combineContent(
    header: string,
    userComments: string[],
    newLines: string[],
    existingLines: string[]
  ): string {
    const parts: string[] = [header.trim()];

    // Add user comments if they exist (and are not just empty comments)
    const realUserComments = userComments.filter(c => {
      const trimmed = c.trim();
      return trimmed && 
             trimmed !== '# User comments:' && 
             trimmed !== '# Generated rules:' &&
             trimmed !== '# Additional existing rules:';
    });
    
    if (realUserComments.length > 0) {
      parts.push('# User comments:');
      parts.push(...realUserComments);
      parts.push('');
    }

    // Add new generated content
    parts.push('# Generated rules:');
    parts.push(...newLines);

    // Add existing content that is not in the new content
    const newLinesSet = new Set(newLines.map(l => l.trim().toLowerCase()));
    
    const additionalLines: string[] = [];
    for (const line of existingLines) {
      const trimmed = line.trim();
      // Ignore empty lines, standard comments, and duplicates
      if (trimmed && 
          !trimmed.startsWith('#') && 
          !newLinesSet.has(trimmed.toLowerCase()) &&
          !trimmed.includes('Generated by smart-gitignore') &&
          !trimmed.includes('Stacks:')) {
        additionalLines.push(line);
      }
    }

    if (additionalLines.length > 0) {
      parts.push('');
      parts.push('# Additional existing rules:');
      parts.push(...additionalLines);
    }

    return parts.join('\n').replace(/\n{3,}/g, '\n\n') + '\n';
  }

  /**
   * Reads existing .gitignore content
   */
  public readExisting(gitignorePath: string): string {
    if (!fs.existsSync(gitignorePath)) {
      return '';
    }
    
    try {
      return fs.readFileSync(gitignorePath, 'utf-8');
    } catch (error) {
      throw new Error(`Error reading existing .gitignore: ${error}`);
    }
  }

  /**
   * Writes final content to .gitignore
   */
  public write(gitignorePath: string, content: string): void {
    try {
      fs.writeFileSync(gitignorePath, content, 'utf-8');
    } catch (error) {
      throw new Error(`Error writing .gitignore: ${error}`);
    }
  }
}

